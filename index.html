<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>最強777 v7.1</title>

<style>
:root{
  --bg:#020617;--card:#0f172a;--line:#1e293b;
  --text:#e5e7eb;--muted:#94a3b8;
  --hot:#ef4444;--warm:#facc15;--cold:#38bdf8;
  --star3:#22c55e;--star2:#facc15;--star1:#ef4444;
  --chip:#0b1220;
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--text);
font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif}
.wrap{max-width:430px;margin:0 auto;padding:16px}
h1{margin:4px 0;font-size:26px}
.sub{font-size:13px;color:var(--muted);margin-bottom:12px}

.card{background:var(--card);border:1px solid var(--line);
border-radius:18px;padding:14px;margin-bottom:14px}

.small{font-size:12px;color:var(--muted)}
hr.sep{border:none;border-top:1px solid var(--line);margin:12px 0}

/* 入力列 */
.boxrow{display:grid;gap:8px}
.boxrow.l6{grid-template-columns:repeat(6,1fr)}
.boxrow.mini{grid-template-columns:repeat(5,1fr)}

.nbox{
  height:48px;border-radius:12px;border:1px solid var(--line);
  background:#020617;color:var(--text);
  text-align:center;font-size:18px;font-weight:800;
}

/* 横1列強制 */
.boxrow.l6,
.boxrow.mini{
  display:flex !important;
  gap:8px !important;
  flex-wrap:nowrap !important;
  width:100% !important;
}
.boxrow.l6 .nbox,
.boxrow.mini .nbox{
  flex:1 1 0 !important;
  min-width:0 !important;
  width:100% !important;
  height:52px !important;
  font-size:18px !important;
  padding:0 !important;
}
@media (max-width: 420px){
  .boxrow.l6,
  .boxrow.mini{ gap:6px !important; }
  .boxrow.l6 .nbox,
  .boxrow.mini .nbox{
    height:48px !important;
    font-size:16px !important;
  }
}

.btnrow{display:flex;gap:10px;margin-top:10px;flex-wrap:wrap}
button{
  flex:1;min-width:140px;height:44px;border-radius:14px;border:1px solid var(--line);
  background:#020617;color:var(--text);font-weight:800
}
button.secondary{background:transparent}
button.danger{border-color:rgba(239,68,68,.35)}
select{
  width:100%;
  height:42px;
  border-radius:12px;
  border:1px solid var(--line);
  background:#020617;
  color:var(--text);
  font-weight:800;
  padding:0 10px;
}

.pool{text-align:center;font-size:20px;font-weight:900;letter-spacing:1px}
.meta{text-align:center;font-size:12px;color:var(--muted);margin-top:6px}

.ticket{border:1px solid var(--line);border-radius:14px;
padding:10px;margin-top:10px}
.stars{text-align:center;font-size:20px;font-weight:900;margin-bottom:4px}
.star3{color:var(--star3)}
.star2{color:var(--star2)}
.star1{color:var(--star1)}
.nums{text-align:center;font-size:18px;font-weight:800;letter-spacing:2px;margin:2px 0 6px}
.chips{display:flex;gap:6px;flex-wrap:wrap;justify-content:center}
.chip{
  font-size:11px;color:var(--muted);
  border:1px solid var(--line);
  background:var(--chip);
  padding:4px 8px;border-radius:999px;
}
.chip.strong{color:#bbf7d0;border-color:rgba(34,197,94,.4)}
.chip.warn{color:#fde68a;border-color:rgba(250,204,21,.4)}
.chip.bad{color:#fecaca;border-color:rgba(239,68,68,.4)}

textarea{width:100%;min-height:60px;background:#020617;
border:1px solid var(--line);color:var(--text);
border-radius:12px;padding:8px}

/* ヒートマップ */
.heathead{
  display:flex;align-items:center;justify-content:space-between;
  gap:10px;flex-wrap:wrap
}
.heatlabel{
  font-size:12px;color:var(--muted);
  border:1px solid var(--line);background:var(--chip);
  padding:6px 10px;border-radius:999px;
}
.heatmap{
  display:grid;
  grid-template-columns:repeat(7,1fr);
  gap:6px;margin-top:10px
}
.hm{
  position:relative;
  text-align:center;padding:6px 0;
  border-radius:10px;font-size:12px;font-weight:900;
  border:1px solid var(--line)
}
.hm.hot{background:rgba(239,68,68,.25);color:var(--hot)}
.hm.warm{background:rgba(250,204,21,.22);color:var(--warm)}
.hm.cold{background:rgba(56,189,248,.22);color:var(--cold)}
.hm.sel{outline:2px solid #e5e7eb}
.trend{
  position:absolute;right:6px;top:2px;
  font-size:12px;font-weight:900;color:#e5e7eb
}

/* 折りたたみ */
details{
  border:1px solid var(--line);
  border-radius:14px;
  padding:10px;
  background:rgba(2,6,23,.35);
}
summary{
  cursor:pointer;
  font-weight:900;
  list-style:none;
}
summary::-webkit-details-marker{display:none}
.summaryRow{
  display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap
}
.badge{
  font-size:11px;color:var(--muted);
  border:1px solid var(--line);background:var(--chip);
  padding:4px 10px;border-radius:999px;
}
</style>
</head>

<body>
<div class="wrap">

<h1>最強777</h1>
<div class="sub">
一致は必ず（引っ張り固定）｜連番必須｜精密引っ張り｜ヒートマップ×トレンド｜履歴は内蔵＋端末保存（ロト6=200/ミニ=100）｜「連続出現」は次回除外｜下一桁同一ペアは必ず“1組だけ”
</div>

<div class="card">
  <h3>前回入力</h3>

  <div class="small">ロト6（前回）</div>
  <div class="boxrow l6" id="l6">
    <input class="nbox" inputmode="numeric" placeholder="--">
    <input class="nbox" inputmode="numeric" placeholder="--">
    <input class="nbox" inputmode="numeric" placeholder="--">
    <input class="nbox" inputmode="numeric" placeholder="--">
    <input class="nbox" inputmode="numeric" placeholder="--">
    <input class="nbox" inputmode="numeric" placeholder="--">
  </div>

  <div class="small" style="margin-top:10px">ミニロト（前回）</div>
  <div class="boxrow mini" id="mini">
    <input class="nbox" inputmode="numeric" placeholder="--">
    <input class="nbox" inputmode="numeric" placeholder="--">
    <input class="nbox" inputmode="numeric" placeholder="--">
    <input class="nbox" inputmode="numeric" placeholder="--">
    <input class="nbox" inputmode="numeric" placeholder="--">
  </div>

  <div class="small" style="margin-top:12px">ナンちゃん式（下一桁ヒント）</div>
  <select id="nanchanMode">
    <option value="A">A：0→3 / 1→4 / 2→5 / … / 7→0 / 8→1 / 9→2</option>
    <option value="B">B：0→2 / 1→3 / 2→4 / … / 8→0 / 9→1</option>
  </select>

  <div class="btnrow">
    <button onclick="calc()">予想生成（各3口）</button>
    <button onclick="showStrong()">★★★のみ</button>
    <button onclick="showAll()">全表示</button>
  </div>

  <div class="meta">
    ロト6だけ入力→ロト6だけ出力OK / ミニロトだけ入力→ミニロトだけ出力OK
  </div>

  <hr class="sep">

  <details id="historyPanel">
    <summary>
      <div class="summaryRow">
        <span>履歴を更新（保存/追記）</span>
        <span class="badge" id="histBadge">ロト6:— / ミニ:—</span>
      </div>
    </summary>

    <div class="small" style="margin-top:10px">
      新しい回を入力して「保存（追記）」→ ロト6は最新200回・ミニは最新100回だけ残して自動更新。
    </div>

    <div class="small" style="margin-top:10px">ロト6（新しい回）</div>
    <div class="boxrow l6" id="l6new">
      <input class="nbox" inputmode="numeric" placeholder="--">
      <input class="nbox" inputmode="numeric" placeholder="--">
      <input class="nbox" inputmode="numeric" placeholder="--">
      <input class="nbox" inputmode="numeric" placeholder="--">
      <input class="nbox" inputmode="numeric" placeholder="--">
      <input class="nbox" inputmode="numeric" placeholder="--">
    </div>

    <div class="small" style="margin-top:10px">ミニロト（新しい回）</div>
    <div class="boxrow mini" id="mininew">
      <input class="nbox" inputmode="numeric" placeholder="--">
      <input class="nbox" inputmode="numeric" placeholder="--">
      <input class="nbox" inputmode="numeric" placeholder="--">
      <input class="nbox" inputmode="numeric" placeholder="--">
      <input class="nbox" inputmode="numeric" placeholder="--">
    </div>

    <div class="btnrow">
      <button onclick="saveAppend()">保存（追記）</button>
      <button class="secondary" onclick="fillPrevFromNew()">新しい回 → 前回欄に反映</button>
    </div>

    <div class="btnrow">
      <button class="danger secondary" onclick="resetToBuiltIn()">内蔵履歴に戻す（初期化）</button>
      <button class="danger secondary" onclick="clearSaved()">保存履歴を全消去</button>
    </div>

    <hr class="sep">

    <div class="small">（任意/非常用）過去履歴（貼り付け：旧）</div>
    <textarea id="history" placeholder="※基本は使わなくてOK。緊急で一時的に貼りたい時だけ。例：03 10 12 20 31 11（改行で複数行OK）"></textarea>
    <div class="meta">※この欄に貼った場合、予想の分析はこの貼り付けを優先します（保存履歴より優先）</div>
  </details>
</div>

<div class="card">
  <div class="heathead">
    <h3 style="margin:0">数字別ヒートマップ</h3>
    <span class="heatlabel" id="heatLabel">—</span>
  </div>
  <div class="btnrow" style="margin-top:10px">
    <button onclick="setHeatMode('l6')">ロト6ヒートマップ</button>
    <button onclick="setHeatMode('mini')">ミニロトヒートマップ</button>
  </div>
  <div class="heatmap" id="heatmap"></div>
  <div class="meta">枠線＝母集団 / ↑↓＝直近トレンド</div>
</div>

<div class="card">
  <h3>勝負日判定</h3>
  <div class="pool" id="battle">—</div>
</div>

<div class="card">
  <h3>ロト6 予想（3口）</h3>
  <div class="pool" id="pool6">—</div>
  <div class="meta" id="meta6">—</div>
  <div id="out6"></div>
</div>

<div class="card">
  <h3>ミニロト 予想（3口）</h3>
  <div class="pool" id="poolM">—</div>
  <div class="meta" id="metaM">—</div>
  <div id="outM"></div>
</div>

</div>

<script>
/* =========================================================
   表示設定
========================================================= */
const DISPLAY_N = 3;  // ← 必ず3口

/* =========================================================
   ✅ 内蔵履歴（ロト6=200回 / ミニ=100回）
   - 最新が先頭（上）
   ※ v7.0 から内容は同一（削除なし）
========================================================= */
const BUILTIN_L6 = [
  [8,18,24,36,40,42],
  [15,24,29,32,33,35],
  [6,10,25,30,34,36],
  [6,17,23,27,33,35],
  [2,10,13,14,29,33],
  [3,4,12,15,32,42],
  [8,28,30,32,37,38],
  [6,18,21,31,37,40],
  [2,7,24,37,39,41],
  [4,28,29,30,38,42],
  [1,9,18,24,35,42],
  [5,6,13,21,33,34],
  [8,16,22,40,41,42],
  [2,13,26,28,38,43],
  [9,12,14,16,19,42],
  [5,7,21,22,38,41],
  [3,7,15,17,19,30],
  [11,12,14,17,21,26],
  [1,14,27,30,33,37],
  [20,28,31,35,37,41],
  [1,3,18,25,30,34],
  [3,15,27,28,31,39],
  [6,11,15,21,25,32],
  [10,24,25,39,40,42],
  [8,13,18,32,37,43],
  [10,11,16,19,37,39],
  [2,5,10,22,25,38],
  [1,4,7,12,16,28],
  [1,6,11,26,33,40],
  [11,19,22,34,40,42],
  [9,14,29,38,41,43],
  [4,19,22,24,32,38],
  [7,12,14,15,24,30],
  [2,15,25,27,38,42],
  [5,31,37,39,41,42],
  [7,12,20,23,27,29],
  [7,10,17,26,35,42],
  [5,10,12,17,21,35],
  [2,13,22,25,35,37],
  [5,16,21,22,33,35],
  [8,15,27,33,37,39],
  [2,3,16,20,23,29],
  [3,7,28,29,32,36],
  [7,21,31,36,40,43],
  [6,10,12,19,21,42],
  [5,12,18,23,34,39],
  [2,5,8,11,20,26],
  [12,18,26,28,41,43],
  [10,13,16,29,34,42],
  [1,20,28,29,31,43],
  [2,3,18,26,31,33],
  [2,17,22,29,30,43],
  [5,21,23,28,38,39],
  [7,13,14,21,39,42],
  [1,2,14,21,22,33],
  [2,4,11,22,24,35],
  [10,13,27,31,40,42],
  [6,8,13,16,20,23],
  [7,11,21,24,29,34],
  [7,12,30,31,39,43],
  [1,14,20,36,38,41],
  [12,14,18,24,30,42],
  [9,15,24,29,31,40],
  [8,17,20,35,36,40],
  [5,8,9,17,22,36],
  [6,18,23,24,30,35],
  [4,7,19,22,26,28],
  [3,7,18,27,33,34],
  [16,18,25,27,31,36],
  [1,5,10,13,35,40],
  [1,17,19,23,36,42],
  [13,21,24,26,34,36],
  [1,2,16,21,25,35],
  [17,31,34,35,36,38],
  [1,4,6,9,20,43],
  [5,16,17,28,36,40],
  [6,17,26,28,33,34],
  [2,4,8,26,27,37],
  [10,11,13,16,24,26],
  [7,12,13,35,37,42],
  [9,11,18,21,27,34],
  [1,5,12,16,17,40],
  [6,9,15,19,24,40],
  [15,17,23,29,35,43],
  [6,20,23,24,33,35],
  [8,12,25,28,32,42],
  [14,20,29,31,41,42],
  [1,30,36,37,41,43],
  [4,19,28,29,34,40],
  [3,18,31,36,37,40],
  [20,21,23,28,32,34],
  [5,10,15,17,29,41],
  [1,2,13,19,35,41],
  [15,18,19,21,37,40],
  [23,25,26,30,34,35],
  [4,14,20,28,29,34],
  [4,6,22,30,33,36],
  [11,13,15,20,35,42],
  [2,6,13,21,24,30],
  [7,10,14,27,28,32],
  [3,14,27,28,32,36],
  [2,6,9,26,32,36],
  [11,26,27,31,36,37],
  [3,7,12,13,35,38],
  [6,13,15,22,35,41],
  [3,4,22,26,29,35],
  [4,12,25,29,34,36],
  [17,18,20,23,33,43],
  [2,5,28,33,35,36],
  [3,4,20,29,35,38],
  [4,8,19,22,32,37],
  [11,12,27,28,38,43],
  [10,22,27,28,31,32],
  [19,20,36,40,41,43],
  [1,15,16,20,21,25],
  [3,4,5,13,34,42],
  [2,19,21,24,35,42],
  [11,19,26,28,29,36],
  [2,10,15,25,35,37],
  [19,23,29,33,36,40],
  [24,25,31,32,34,40],
  [1,3,6,23,28,35],
  [9,20,26,28,30,42],
  [12,13,17,28,37,43],
  [18,29,30,38,39,43],
  [10,24,30,36,37,41],
  [8,9,11,27,36,38],
  [1,2,4,14,27,43],
  [6,11,21,33,39,42],
  [10,11,17,25,34,38],
  [1,16,18,26,27,35],
  [2,12,13,21,23,43],
  [2,14,15,25,26,42],
  [10,22,26,27,29,37],
  [5,9,14,32,39,41],
  [1,9,26,28,31,38],
  [1,6,19,29,33,35],
  [3,8,12,14,17,40],
  [6,13,16,20,27,41],
  [3,7,9,10,12,30],
  [1,5,16,20,24,31],
  [9,23,27,30,33,41],
  [5,10,19,23,29,37],
  [7,10,12,20,40,43],
  [2,18,20,24,26,29],
  [2,11,18,26,32,36],
  [10,13,18,24,34,37],
  [5,9,11,18,34,37],
  [7,16,18,25,26,27],
  [6,7,18,30,34,37],
  [3,11,22,31,33,35],
  [1,2,13,25,33,41],
  [6,10,22,23,31,36],
  [5,17,19,21,38,41],
  [3,4,5,6,18,20],
  [3,12,14,29,30,33],
  [5,13,18,23,30,39],
  [4,10,14,19,24,40],
  [4,10,22,24,36,38],
  [2,5,22,23,29,33],
  [1,11,24,29,33,34],
  [4,8,9,14,16,41],
  [2,8,24,29,30,31],
  [3,5,7,8,22,27],
  [3,9,21,25,42,43],
  [10,14,21,23,24,40],
  [1,8,21,22,30,42],
  [4,5,17,20,29,30],
  [14,21,23,24,28,36],
  [18,19,23,25,27,32],
  [4,7,15,18,35,40],
  [14,15,26,28,33,37],
  [3,9,29,30,39,42],
  [2,4,9,19,33,36],
  [5,19,23,26,31,42],
  [7,23,27,30,34,36],
  [5,12,15,16,28,40],
  [6,18,29,33,35,40],
  [19,29,36,37,41,42],
  [25,31,33,35,37,42],
  [7,8,9,19,22,38],
  [2,16,23,38,40,43],
  [17,21,29,34,41,42],
  [7,15,21,27,28,32],
  [4,5,6,28,29,39],
  [5,7,15,18,36,37],
  [1,6,19,25,33,39],
  [2,6,7,16,17,41],
  [20,25,29,36,38,42],
  [3,11,24,25,28,32],
  [3,6,11,25,36,43],
  [2,9,22,31,33,35],
  [9,14,21,31,33,43],
  [1,8,14,27,29,37],
  [6,8,12,18,32,38],
  [1,11,13,16,21,37],
  [4,7,17,31,38,43],
  [11,15,16,24,38,39],
  [13,31,33,36,41,43],
  [6,15,26,33,39,41]
];

const BUILTIN_MINI = [
  [3,10,12,20,31],
  [1,5,12,24,31],
  [1,2,3,5,11],
  [7,8,20,25,26],
  [17,21,27,28,29],
  [3,19,20,21,28],
  [3,10,20,25,27],
  [1,3,10,27,31],
  [6,12,16,19,31],
  [6,12,13,17,26],
  [20,25,26,27,30],
  [4,18,20,24,29],
  [1,3,15,16,20],
  [1,6,22,27,29],
  [7,9,21,25,28],
  [6,7,20,22,24],
  [3,6,10,23,27],
  [11,13,15,16,26],
  [6,11,13,14,18],
  [5,8,10,11,29],
  [4,9,10,19,29],
  [2,3,11,22,28],
  [2,3,15,28,29],
  [4,16,20,26,28],
  [4,16,18,27,31],
  [5,16,20,23,30],
  [3,11,14,30,31],
  [2,5,21,24,28],
  [4,13,22,29,30],
  [1,9,13,19,23],
  [5,12,16,24,28],
  [8,19,22,24,27],
  [6,14,21,23,31],
  [13,18,21,28,31],
  [3,11,17,20,22],
  [3,20,21,24,25],
  [12,17,18,22,31],
  [3,8,21,27,29],
  [7,11,18,25,26],
  [12,16,17,20,25],
  [9,11,13,27,28],
  [1,13,24,25,31],
  [5,6,8,21,30],
  [1,12,15,27,31],
  [4,9,26,27,29],
  [4,9,15,19,26],
  [10,15,22,23,25],
  [5,6,14,20,27],
  [4,9,18,24,25],
  [5,16,18,22,28],
  [1,5,6,24,25],
  [2,3,7,25,28],
  [4,6,16,26,29],
  [5,7,15,24,29],
  [7,22,26,30,31],
  [4,7,10,11,17],
  [6,15,22,29,30],
  [18,20,21,23,30],
  [2,5,9,22,31],
  [10,12,13,21,31],
  [3,11,27,28,31],
  [6,12,18,20,27],
  [1,8,12,14,29],
  [3,6,17,22,25],
  [5,9,18,24,30],
  [2,7,13,24,31],
  [4,6,10,21,23],
  [1,11,16,22,28],
  [3,14,19,25,31],
  [6,8,15,21,29],
  [2,10,12,20,24],
  [5,7,18,26,30],
  [1,6,14,22,27],
  [4,9,11,19,28],
  [3,5,16,24,31],
  [2,8,17,21,25],
  [7,12,15,23,29],
  [6,10,18,20,31],
  [1,4,14,22,30],
  [3,9,16,24,27],
  [5,11,18,25,28],
  [2,6,12,21,31],
  [1,7,14,20,29],
  [4,8,18,22,25],
  [3,10,15,24,30],
  [5,9,16,21,27],
  [2,11,14,23,31],
  [6,8,19,25,29],
  [1,4,12,20,28],
  [3,7,16,22,31],
  [5,10,18,24,27],
  [2,6,15,21,29],
  [1,9,14,23,30],
  [4,8,19,25,31],
  [3,7,12,20,28],
  [5,10,16,22,29],
  [2,6,18,24,31],
  [1,9,14,21,27],
  [4,8,15,23,30],
  [3,7,16,20,28]
];

/* =========================================================
   ✅ 保存（端末内 localStorage）
========================================================= */
const LS_KEYS = {
  l6:   "s777_hist_l6_v2",
  mini: "s777_hist_mini_v2",
  seeded:"s777_seeded_v2"
};
const CAP = { l6:200, mini:100 };

function normSet(nums){ return nums.slice().sort((a,b)=>a-b).join(","); }
function loadSaved(game){
  try{
    const raw = localStorage.getItem(LS_KEYS[game]);
    if(!raw) return [];
    const arr = JSON.parse(raw);
    if(!Array.isArray(arr)) return [];
    return arr.filter(x => Array.isArray(x)).map(r => r.slice().sort((a,b)=>a-b));
  }catch(e){ return []; }
}
function saveSaved(game, data){ localStorage.setItem(LS_KEYS[game], JSON.stringify(data)); }
function ensureCap(game){
  const data = loadSaved(game);
  if(data.length<=CAP[game]) return;
  saveSaved(game, data.slice(0, CAP[game]));
}
function appendUnique(game, nums){
  const data = loadSaved(game);
  const key = normSet(nums);
  if(data.some(r => normSet(r)===key)){
    return {ok:false, reason:"同じ組み合わせが既に保存済み"};
  }
  data.unshift(nums.slice().sort((a,b)=>a-b));
  saveSaved(game, data.slice(0, CAP[game]));
  return {ok:true, count:Math.min(data.length, CAP[game])};
}
function seedIfNeeded(){
  const already = localStorage.getItem(LS_KEYS.seeded);
  if(already==="1") return;

  const l6 = loadSaved("l6");
  const mi = loadSaved("mini");

  if(l6.length===0) saveSaved("l6", BUILTIN_L6.slice(0, CAP.l6));
  if(mi.length===0) saveSaved("mini", BUILTIN_MINI.slice(0, CAP.mini));

  localStorage.setItem(LS_KEYS.seeded, "1");
}

/* =========================================================
   状態
========================================================= */
let STATE = {
  heatMode: "l6",
  lastInputs: { l6:null, mini:null },
  pools: { l6:null, mini:null },
  histories: { l6:[], mini:[] }
};

/* =========================================================
   共通（入力・判定）
========================================================= */
function read(id,c,max){
  const v=[...document.querySelectorAll("#"+id+" .nbox")]
    .map(x=>String(x.value||"").trim())
    .filter(x=>x!=="")
    .map(Number);

  if(v.length!==c) return null;
  if(v.some(n=>Number.isNaN(n))) return null;
  if(new Set(v).size!==v.length) return null;
  if(v.some(n=>n<1||n>max)) return null;
  return v.sort((a,b)=>a-b);
}
function hasSeq(a){
  for(let i=0;i<a.length-1;i++) if(a[i+1]-a[i]===1) return true;
  return false;
}
function overlapCount(a,b){
  const set=new Set(b);
  return a.filter(x=>set.has(x)).length;
}
function parseHistory(){
  const raw=document.getElementById("history").value.trim();
  if(!raw) return [];
  return raw
    .split("\n")
    .map(r=>r.trim())
    .filter(r=>r.length>0)
    .map(r=>r.split(/\s+/).map(Number).filter(n=>!Number.isNaN(n)));
}
function getHistoryFor(game){
  const pasted = parseHistory();
  if(pasted.length>0) return pasted.map(r=>r.slice().sort((a,b)=>a-b));
  return loadSaved(game);
}

/* =========================================================
   トレンド
========================================================= */
function trendOf(n,history){
  if(history.length<4) return "→";
  const half=Math.floor(history.length/2);
  const a=history.slice(0,half).filter(h=>h.includes(n)).length;
  const b=history.slice(half).filter(h=>h.includes(n)).length;
  if(b>a) return "↑";
  if(b<a) return "↓";
  return "→";
}

/* =========================================================
   ヒートマップ
========================================================= */
function buildHeatmap(history,max,selected){
  const map=document.getElementById("heatmap");
  map.innerHTML="";
  for(let n=1;n<=max;n++){
    let gap=0,freq=0;
    for(let h of history){ if(h.includes(n)) break; gap++; }
    history.forEach(h=>{ if(h.includes(n)) freq++; });

    let cls="warm";
    if(gap>=5) cls="hot";
    else if(freq>=3) cls="cold";

    const d=document.createElement("div");
    d.className="hm "+cls+(selected.includes(n)?" sel":"");
    d.innerHTML=`${String(n).padStart(2,"0")}<span class="trend">${trendOf(n,history)}</span>`;
    map.appendChild(d);
  }
}
function setHeatMode(mode){ STATE.heatMode = mode; refreshHeatmap(); }
function refreshHeatmap(){
  const label = document.getElementById("heatLabel");
  if(STATE.heatMode==="l6"){
    if(!STATE.pools.l6){
      label.textContent = "ロト6：未生成（ロト6を入力して予想生成）";
      document.getElementById("heatmap").innerHTML="";
      return;
    }
    label.textContent = `ロト6（1〜43）｜履歴${STATE.histories.l6.length}回（上限200）`;
    buildHeatmap(STATE.histories.l6, 43, STATE.pools.l6.pool);
    return;
  }
  if(!STATE.pools.mini){
    label.textContent = "ミニロト：未生成（ミニロトを入力して予想生成）";
    document.getElementById("heatmap").innerHTML="";
    return;
  }
  label.textContent = `ミニロト（1〜31）｜履歴${STATE.histories.mini.length}回（上限100）`;
  buildHeatmap(STATE.histories.mini, 31, STATE.pools.mini.pool);
}

/* =========================================================
   連続出現（前回＆前々回の被り） → 次回は除外
========================================================= */
function getPrevDraw(last, history){
  if(!history || history.length===0) return null;
  const h0 = history[0].slice().sort((a,b)=>a-b);
  if(normSet(h0)===normSet(last)){
    return history.length>=2 ? history[1].slice().sort((a,b)=>a-b) : null;
  }
  return h0;
}
function intersection(a,b){
  if(!a || !b) return [];
  const set = new Set(b);
  return a.filter(x=>set.has(x));
}

/* =========================================================
   ナンちゃん式：下一桁ヒント（画像ベース）
   A: 0→3,1→4,...,6→9,7→0,8→1,9→2
   B: 0→2,1→3,...,7→9,8→0,9→1
========================================================= */
function nanchanMap(mode){
  const A = {0:3,1:4,2:5,3:6,4:7,5:8,6:9,7:0,8:1,9:2};
  const B = {0:2,1:3,2:4,3:5,4:6,5:7,6:8,7:9,8:0,9:1};
  return mode==="B" ? B : A;
}

/* =========================================================
   “下一桁同一ペア”のルール
   - チケット内で「同じ下一桁が2個」→ これが必ず1組だけ
   - 3個以上はNG、2組以上もNG
========================================================= */
function lastDigit(n){ return ((n%10)+10)%10; }
function exactlyOneSameLastDigitPair(ticket, targetDigit){
  const cnt = {};
  for(const n of ticket){
    const d = lastDigit(n);
    cnt[d] = (cnt[d]||0) + 1;
    if(cnt[d] > 2) return false; // 3個以上は即NG
  }
  const pairs = Object.entries(cnt).filter(([d,c])=>c===2).map(([d])=>Number(d));
  if(pairs.length !== 1) return false;
  return pairs[0] === targetDigit;
}

/* targetDigit を決める
   1) 前回に「下一桁が2回以上出た」digitがあれば、そこから選ぶ（優先）
   2) なければ、pullの下一桁をナンちゃん式で変換して採用
*/
function choosePairDigit(last, pulls, mode){
  const digitCounts = {};
  last.forEach(n=>{
    const d = lastDigit(n);
    digitCounts[d] = (digitCounts[d]||0) + 1;
  });
  const dupDigits = Object.entries(digitCounts)
    .filter(([d,c])=>c>=2)
    .map(([d])=>Number(d));

  if(dupDigits.length>0){
    // “前回の中で、より中央寄り”のdigitを雑に優先
    // → そのdigitの中で最小の数字を基準に評価
    let best = dupDigits[0], bestScore=-1;
    dupDigits.forEach(d=>{
      const nums = last.filter(n=>lastDigit(n)===d);
      const base = Math.min(...nums);
      const s = 10 - Math.abs(d - lastDigit(base)); // ほぼ一定だけど、同率回避用
      if(s>bestScore){ bestScore=s; best=d; }
    });
    return best;
  }

  // dupなし → ナンちゃん式
  const map = nanchanMap(mode);
  const p = pulls && pulls.length>0 ? pulls[0] : last[0];
  const d = lastDigit(p);
  return map[d];
}

/* =========================================================
   pullスコア（精密）※既存ベース
========================================================= */
function pickPullScore(n,last,history,type){
  const avg=last.reduce((a,b)=>a+b,0)/last.length;
  let s=0;

  s += 6 - Math.min(Math.abs(n-avg), 6);

  let g=0; for(let h of history){ if(h.includes(n)) break; g++; }
  s += Math.min(g, 6);

  let f=0; history.forEach(h=>{ if(h.includes(n)) f++; });
  if(f<=1) s += 3;
  if(f>=4) s -= 2;

  if(type==="l6"){
    if(n>=10 && n<=30) s += 1;
  }else{
    if(n>=8 && n<=22) s += 0.8;
  }
  return s;
}

/* =========================================================
   ミニのpull個数（基本1〜2：スコアで可変）
   - 直近の“連続出現”が少ないほど2個寄り
   - 連続出現が多いほど1個寄り
========================================================= */
function decideMiniPullCount(last, history){
  const prev = getPrevDraw(last, history);
  const rep = intersection(last, prev).length;
  // 連続が2個以上なら守って1個、そうでなければ2個寄り
  return (rep>=2) ? 1 : 2;
}

/* =========================================================
   pull選択
   - 連続出現（前回＆前々回の被り）は pull候補から除外
   - ロト6：必ず1個
   - ミニ：1〜2個（decideMiniPullCount）
========================================================= */
function pickPulls(last, history, type, count, bannedRepeatSet){
  const candidates = last.filter(n => !bannedRepeatSet.has(n));
  if(candidates.length===0){
    // 全部連続扱いみたいなケースは、仕方なく last から復活
    candidates.push(...last);
  }

  const scored = candidates.map(n => ({n, s: pickPullScore(n,last,history,type)}));
  scored.sort((a,b)=>b.s-a.s);

  const pulls = [];
  for(const o of scored){
    if(pulls.length>=count) break;
    pulls.push(o.n);
  }

  // 最後に重複整形
  return Array.from(new Set(pulls)).sort((a,b)=>a-b);
}

/* =========================================================
   候補採点（前回以外 / 禁止セット除外）
========================================================= */
function pickCandidates(max,banSet,history,needCount){
  const cand=[];
  for(let n=1;n<=max;n++){
    if(banSet.has(n)) continue;
    let s=0;

    let g=0; for(let h of history){ if(h.includes(n)) break; g++; }
    s += Math.min(g, 6) * 1.2;

    let f=0; history.forEach(h=>{ if(h.includes(n)) f++; });
    if(f===0) s += 1.5;
    if(f===1) s += 1.0;
    if(f>=4) s -= 1.5;

    const t=trendOf(n,history);
    if(t==="↑") s += 0.7;
    if(t==="↓") s -= 0.3;

    cand.push({n,s});
  }
  cand.sort((a,b)=>b.s-a.s);
  return cand.slice(0,needCount).map(x=>x.n);
}

/* =========================================================
   プール生成（重要）
   - pullは1〜2（ロト6=1固定 / ミニ=1〜2）
   - 前回から pull以外は入れない
   - さらに「前回＆前々回の連続出現」は次回チケットから全除外
========================================================= */
function buildPoolStrictV2(last, prev, max, size, history, type, pullCount, nanchanMode){
  const repeated = new Set(intersection(last, prev));   // 連続出現 → 全部禁止
  const pulls = pickPulls(last, history, type, pullCount, repeated);

  // 前回のうち、pull以外は全部禁止（従来通り）
  const banFromLast = new Set(last.filter(n => !pulls.includes(n)));

  // 禁止セット：連続出現 + 前回pull以外
  const ban = new Set([...repeated, ...banFromLast]);

  // プールを作る：pull + 候補
  const pool = pulls.slice();
  const need = size - pool.length;
  const picked = pickCandidates(max, new Set([...ban, ...pool]), history, need);
  picked.forEach(n=>pool.push(n));

  // pair digit（下一桁同一ペアのdigit）を決める
  const pairDigit = choosePairDigit(last, pulls, nanchanMode);

  return {
    pool: Array.from(new Set(pool)).sort((a,b)=>a-b),
    pulls,
    repeated: Array.from(repeated).sort((a,b)=>a-b),
    pairDigit,
    pullCount: pulls.length
  };
}

function comb(a,k){
  const r=[];
  const f=(s,c)=>{
    if(c.length===k){ r.push([...c]); return; }
    for(let i=s;i<a.length;i++){ c.push(a[i]); f(i+1,c); c.pop(); }
  };
  f(0,[]);
  return r;
}

/* =========================================================
   スコア（厳しめ）※既存ベース
========================================================= */
function zoneCount(nums, type){
  let s=0,m=0,l=0;
  nums.forEach(n=>{
    if(type==="l6"){
      if(n<=15) s++; else if(n<=31) m++; else l++;
    }else{
      if(n<=10) s++; else if(n<=20) m++; else l++;
    }
  });
  return {s,m,l};
}
function scoreTicket(t,last,history,type,requiredOv){
  let s=0;

  if(hasSeq(t)) s += 6;

  const ov = overlapCount(t,last);
  if(ov===requiredOv) s += 8;
  else s -= 999;

  t.forEach(n=>{
    let g=0; for(let h of history){ if(h.includes(n)) break; g++; }
    s += Math.min(g, 6) * 1.1;
  });

  t.forEach(n=>{
    const tr=trendOf(n,history);
    if(tr==="↑") s += 0.4;
    if(tr==="↓") s -= 0.1;
  });

  const z=zoneCount(t,type);
  const maxZ=Math.max(z.s,z.m,z.l);
  if(maxZ>= (type==="l6"?5:4)) s -= 1.2;

  return Math.round(s*10)/10;
}
function stars(sc){
  if(sc>=20.0) return 3;
  if(sc>=16.0) return 2;
  return 1;
}
function labelByStar(st){
  if(st===3) return {txt:"強い", cls:"strong"};
  if(st===2) return {txt:"強気", cls:"warn"};
  return {txt:"堅い", cls:"bad"};
}
function countSeqPairs(a){
  let c=0;
  for(let i=0;i<a.length-1;i++) if(a[i+1]-a[i]===1) c++;
  return c;
}

/* =========================================================
   描画（3口固定）
   - 連番必須
   - pullは必須
   - 一致数は pullCount と一致（ロト6=1 / ミニ=1〜2）
   - pull以外の前回数字混入禁止
   - “連続出現”数字は全禁止
   - 下一桁同一ペアは「1組だけ」＆ digit固定
========================================================= */
function renderTicketsTopN(rootId, list, last, prev, history, type, pulls, repeatedBanArr, pairDigit){
  const root=document.getElementById(rootId);
  root.innerHTML="";

  const repeatedBan = new Set(repeatedBanArr || []);
  const requiredOv = pulls.length;
  const banOthers = new Set(last.filter(n => !pulls.includes(n)));

  const keep=[];

  list.forEach(t=>{
    t = t.slice().sort((a,b)=>a-b);

    if(!hasSeq(t)) return;

    // pull必須（全て含む）
    for(const p of pulls){
      if(!t.includes(p)) return;
    }

    // 一致数は pull数と一致
    const ov = overlapCount(t,last);
    if(ov!==requiredOv) return;

    // pull以外の前回数字混入禁止
    for(const n of t){
      if(banOthers.has(n)) return;
    }

    // 連続出現は禁止（次回入らない想定）
    for(const n of t){
      if(repeatedBan.has(n)) return;
    }

    // 下一桁同一ペア：必ず1組だけ＆digit固定
    if(!exactlyOneSameLastDigitPair(t, pairDigit)) return;

    const sc = scoreTicket(t,last,history,type,requiredOv);
    const st = stars(sc);
    keep.push({t,sc,st,ov});
  });

  keep.sort((a,b)=>b.sc-a.sc);

  // 3口固定（足りない場合はあるだけ）
  const top = keep.slice(0, DISPLAY_N);

  top.forEach(o=>{
    const st=o.st;
    const lab=labelByStar(st);
    const z=zoneCount(o.t,type);

    const d=document.createElement("div");
    d.className="ticket";
    d.innerHTML=`
      <div class="stars star${st}">${"★".repeat(st)}</div>
      <div class="nums">${o.t.map(x=>String(x).padStart(2,"0")).join(" ")}</div>
      <div class="chips">
        <span class="chip ${lab.cls}">${lab.txt}</span>
        <span class="chip">一致:${o.ov}</span>
        <span class="chip">連番:${countSeqPairs(o.t)}</span>
        <span class="chip">下一桁ペア:${pairDigit}</span>
        <span class="chip">小中大:${z.s}-${z.m}-${z.l}</span>
        <span class="chip">Score:${o.sc}</span>
      </div>
    `;
    root.appendChild(d);
  });

  // もし条件が厳しすぎて0件のとき、ガイドを出す（機能削除ではなく補助）
  if(top.length===0){
    const guide=document.createElement("div");
    guide.className="meta";
    guide.style.marginTop="10px";
    guide.textContent="条件が厳しすぎて3口作れなかったよ（連続出現除外＋下一桁ペア固定＋連番必須）。履歴や前回入力を見直すか、次の回で再生成してね。";
    root.appendChild(guide);
  }
}

/* =========================================================
   メイン（ロト6だけ / ミニだけ OK）
========================================================= */
function calc(){
  const l6 = read("l6",6,43);
  const m  = read("mini",5,31);

  if(!l6 && !m){
    alert("入力不足（ロト6=6個 or ミニロト=5個 のどちらかは必要）");
    return;
  }

  const nmode = document.getElementById("nanchanMode").value;

  STATE.histories.l6   = getHistoryFor("l6");
  STATE.histories.mini = getHistoryFor("mini");

  // ---- ロト6 ----
  if(l6){
    const prev = getPrevDraw(l6, STATE.histories.l6);
    const p6 = buildPoolStrictV2(
      l6, prev, 43, 7, STATE.histories.l6, "l6",
      1, // ロト6 pullは必ず1個
      nmode
    );

    STATE.lastInputs.l6 = l6;
    STATE.pools.l6 = p6;

    // heat枠線は“プール”
    document.getElementById("pool6").textContent = p6.pool.map(x=>String(x).padStart(2,"0")).join(" ");
    const repTxt = (p6.repeated.length>0) ? p6.repeated.map(x=>String(x).padStart(2,"0")).join(" ") : "なし";
    document.getElementById("meta6").textContent =
      `引っ張り:${p6.pulls.map(x=>String(x).padStart(2,"0")).join(" ")}（一致=${p6.pullCount}）｜連続出現→次回除外:${repTxt}｜下一桁同一ペア: digit=${p6.pairDigit}（1組だけ固定）`;

    renderTicketsTopN(
      "out6",
      comb(p6.pool, 6),
      l6,
      prev,
      STATE.histories.l6,
      "l6",
      p6.pulls,
      p6.repeated,
      p6.pairDigit
    );
  }else{
    STATE.lastInputs.l6 = null;
    STATE.pools.l6 = null;
    document.getElementById("pool6").textContent="—";
    document.getElementById("meta6").textContent="ロト6未入力（ロト6だけ予想したいならロト6を6個入力）";
    document.getElementById("out6").innerHTML="";
  }

  // ---- ミニロト ----
  if(m){
    const prev = getPrevDraw(m, STATE.histories.mini);
    const pullCount = decideMiniPullCount(m, STATE.histories.mini); // 1〜2
    const pm = buildPoolStrictV2(
      m, prev, 31, 6, STATE.histories.mini, "mini",
      pullCount,
      nmode
    );

    STATE.lastInputs.mini = m;
    STATE.pools.mini = pm;

    document.getElementById("poolM").textContent = pm.pool.map(x=>String(x).padStart(2,"0")).join(" ");
    const repTxt = (pm.repeated.length>0) ? pm.repeated.map(x=>String(x).padStart(2,"0")).join(" ") : "なし";
    document.getElementById("metaM").textContent =
      `引っ張り:${pm.pulls.map(x=>String(x).padStart(2,"0")).join(" ")}（一致=${pm.pullCount}）｜連続出現→次回除外:${repTxt}｜下一桁同一ペア: digit=${pm.pairDigit}（1組だけ固定）`;

    renderTicketsTopN(
      "outM",
      comb(pm.pool, 5),
      m,
      prev,
      STATE.histories.mini,
      "mini",
      pm.pulls,
      pm.repeated,
      pm.pairDigit
    );
  }else{
    STATE.lastInputs.mini = null;
    STATE.pools.mini = null;
    document.getElementById("poolM").textContent="—";
    document.getElementById("metaM").textContent="ミニロト未入力（ミニロトだけ予想したいならミニロトを5個入力）";
    document.getElementById("outM").innerHTML="";
  }

  // ヒートマップ：入力がある方に自動寄せ
  if(STATE.heatMode==="l6" && !STATE.pools.l6 && STATE.pools.mini) STATE.heatMode="mini";
  if(STATE.heatMode==="mini" && !STATE.pools.mini && STATE.pools.l6) STATE.heatMode="l6";
  refreshHeatmap();

  judge();
  updateBadge();
}

/* =========================================================
   勝負日判定（入力された側だけで判定）
========================================================= */
function judge(){
  const a = document.querySelectorAll("#out6 .star3").length;
  const b = document.querySelectorAll("#outM .star3").length;
  const el=document.getElementById("battle");

  const hasL6 = !!STATE.pools.l6;
  const hasM  = !!STATE.pools.mini;

  if(hasL6 && !hasM){
    el.textContent = (a>=2) ? "今日はロト6全力（勝負日）" : "今日はロト6寄せ";
    return;
  }
  if(!hasL6 && hasM){
    el.textContent = (b>=2) ? "今日はミニロト厚め（勝負日）" : "今日はミニロト寄せ";
    return;
  }

  if(a>=2 && a>b) el.textContent="今日はロト6全力（勝負日）";
  else if(b>=2 && b>a) el.textContent="今日はミニロト厚め（勝負日）";
  else if(a>b) el.textContent="今日はロト6寄せ";
  else if(b>a) el.textContent="今日はミニロト寄せ";
  else el.textContent="両方様子見";
}

/* 既存機能は残す（3口でも動く） */
function showStrong(){
  document.querySelectorAll(".ticket").forEach(t=>{
    if(!t.querySelector(".star3")) t.style.display="none";
  });
}
function showAll(){
  document.querySelectorAll(".ticket").forEach(t=>t.style.display="block");
}

/* =========================================================
   履歴：追記（新しい回）
========================================================= */
function updateBadge(){
  const l6c = loadSaved("l6").length;
  const mc  = loadSaved("mini").length;
  document.getElementById("histBadge").textContent = `ロト6:${l6c}回 / ミニ:${mc}回`;
}

function saveAppend(){
  const l6n = read("l6new",6,43);
  const mn  = read("mininew",5,31);

  if(!l6n && !mn){
    alert("保存する数字がない（ロト6=6個 or ミニ=5個 のどちらかを入力）");
    return;
  }

  let msg = [];

  if(l6n){
    const r = appendUnique("l6", l6n);
    msg.push(r.ok ? `ロト6 保存OK（累計${r.count}/200）` : `ロト6 保存NG：${r.reason}`);
    ensureCap("l6");
  }
  if(mn){
    const r = appendUnique("mini", mn);
    msg.push(r.ok ? `ミニ 保存OK（累計${r.count}/100）` : `ミニ 保存NG：${r.reason}`);
    ensureCap("mini");
  }

  updateBadge();

  // 保存後：前回欄に自動反映
  if(l6n){
    const boxes = [...document.querySelectorAll("#l6 .nbox")];
    l6n.forEach((v,i)=>{ if(boxes[i]) boxes[i].value = String(v); });
  }
  if(mn){
    const boxes = [...document.querySelectorAll("#mini .nbox")];
    mn.forEach((v,i)=>{ if(boxes[i]) boxes[i].value = String(v); });
  }

  alert(msg.join("\n") + "\n\n※保存した数字を「前回入力」に自動反映したよ");
}

function fillPrevFromNew(){
  const l6n = read("l6new",6,43);
  const mn  = read("mininew",5,31);

  if(!l6n && !mn){
    alert("反映する数字がない（新しい回を入力してね）");
    return;
  }

  if(l6n){
    const boxes = [...document.querySelectorAll("#l6 .nbox")];
    l6n.forEach((v,i)=>{ if(boxes[i]) boxes[i].value = String(v); });
  }
  if(mn){
    const boxes = [...document.querySelectorAll("#mini .nbox")];
    mn.forEach((v,i)=>{ if(boxes[i]) boxes[i].value = String(v); });
  }
  alert("前回欄に反映したよ。");
}

function clearSaved(){
  const ok = confirm("保存履歴をすべて消します。戻せません。OK？");
  if(!ok) return;
  localStorage.removeItem(LS_KEYS.l6);
  localStorage.removeItem(LS_KEYS.mini);
  updateBadge();
  alert("保存履歴を消去しました。");
}

function resetToBuiltIn(){
  const ok = confirm("内蔵履歴に戻します。今の保存履歴は上書きされます。OK？");
  if(!ok) return;
  saveSaved("l6", BUILTIN_L6.slice(0, CAP.l6));
  saveSaved("mini", BUILTIN_MINI.slice(0, CAP.mini));
  ensureCap("l6");
  ensureCap("mini");
  updateBadge();
  alert("内蔵履歴に戻したよ。");
}

/* 初期化 */
(function init(){
  seedIfNeeded();
  ensureCap("l6");
  ensureCap("mini");
  updateBadge();
  refreshHeatmap();
})();
</script>
</body>
</html>
