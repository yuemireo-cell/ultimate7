<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>最強777（勝負日モード）</title>

  <!-- PWA（アイコン無しでも動く） -->
  <link rel="manifest" href="./manifest.json" />
  <meta name="theme-color" content="#0b1220" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <style>
    :root{
      --bg:#0b1220; --card: rgba(18,26,44,.92); --line: rgba(34,48,79,.80);
      --text:#e7eefc; --muted:#93a4c7;
      --good:#22c55e; --warn:#f59e0b; --bad:#ef4444;
      --chip: rgba(15,23,42,.55);
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --r:16px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background: linear-gradient(180deg, #070b14, var(--bg));
      color:var(--text);
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Hiragino Sans","Noto Sans JP",sans-serif;
    }
    .wrap{max-width:860px;margin:0 auto;padding:14px 14px 26px}
    header{padding:14px 12px 8px}
    h1{margin:0 0 6px;font-size:20px;letter-spacing:.08em}
    .sub{color:var(--muted);font-size:12px;line-height:1.35}
    .card{
      background:var(--card); border:1px solid var(--line); border-radius:var(--r);
      box-shadow:var(--shadow); padding:14px; margin:12px 0;
    }
    .card h2{margin:0 0 10px;font-size:16px;letter-spacing:.06em;display:flex;justify-content:space-between;align-items:center;gap:10px}
    .note{color:var(--muted);font-size:12px}
    .split{height:1px;background:rgba(34,48,79,.55);margin:12px 0}

    .gridLabel{display:flex;justify-content:space-between;align-items:flex-end;gap:10px;flex-wrap:wrap}
    .smalltag{color:var(--muted);font-size:12px}

    .numgrid{display:grid;grid-template-columns: repeat(6, 1fr);gap:8px;margin-top:10px}
    .numgrid.mini{grid-template-columns: repeat(5, 1fr);}
    .box{
      background:rgba(15,23,42,.35);
      border:1px solid rgba(34,48,79,.8);
      border-radius:14px;
      padding:8px 6px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
    }
    .box input{
      width:100%; background:transparent; border:none; outline:none;
      color:var(--text); font-size:20px; font-weight:800; text-align:center;
      padding:8px 0; font-variant-numeric: tabular-nums;
    }
    .box input::placeholder{color:rgba(147,164,199,.35);font-weight:700}
    .box .cap{margin-top:2px;text-align:center;color:rgba(147,164,199,.65);font-size:10px}

    .btns{display:flex;gap:10px}
    button{
      appearance:none;border:1px solid rgba(34,48,79,.9);
      background:linear-gradient(180deg, rgba(59,92,190,.20), rgba(59,92,190,.08));
      color:var(--text); padding:12px 14px; border-radius:14px; font-weight:800;
      width:100%; box-shadow: 0 10px 26px rgba(0,0,0,.22); cursor:pointer;
    }
    button.secondary{
      background:linear-gradient(180deg, rgba(30,41,59,.25), rgba(30,41,59,.10));
    }
    button:active{transform:translateY(1px)}

    .statusBar{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .pill{
      display:flex;align-items:center;justify-content:space-between;
      padding:10px 12px;border-radius:14px;background:rgba(15,23,42,.35);
      border:1px solid rgba(34,48,79,.7);
      min-width: 220px; flex:1;
    }
    .dot{width:10px;height:10px;border-radius:50%}
    .dot.good{background:var(--good)}
    .dot.warn{background:var(--warn)}
    .dot.bad{background:var(--bad)}
    .dot.idle{background:#64748b}
    .pill .left{display:flex;align-items:flex-start;gap:10px}
    .pill .t1{font-weight:800}
    .pill .t2{color:var(--muted);font-size:12px;margin-top:2px}
    .pill .right{color:var(--muted);font-size:12px}

    .mono{font-variant-numeric: tabular-nums}

    .outTop{
      display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between
    }
    .bigNum{
      background:rgba(15,23,42,.30);
      border:1px solid rgba(34,48,79,.65);
      border-radius:14px;
      padding:12px 12px;
      font-size:22px;
      font-weight:900;
      letter-spacing:.08em;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
      width:100%;
    }
    .bigMeta{color:var(--muted);font-size:12px;margin-top:6px}

    .ticket{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:10px 12px;border-radius:14px;background:rgba(15,23,42,.25);
      border:1px solid rgba(34,48,79,.60);
      margin-top:10px;
    }
    .stars{
      min-width:68px;
      display:flex;align-items:center;justify-content:center;
      background:rgba(15,23,42,.35);
      border:1px solid rgba(34,48,79,.65);
      border-radius:12px;
      padding:8px 10px;
      font-weight:900;
      letter-spacing:.08em;
    }
    .tMain{flex:1}
    .tNums{font-weight:900;font-size:18px;letter-spacing:.10em}
    .chips{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
    .chip{
      background:var(--chip);
      border:1px solid rgba(34,48,79,.65);
      border-radius:999px;
      padding:6px 10px;
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
    }
    .chip.good{color:#b9f6c9;border-color:rgba(34,197,94,.35)}
    .chip.warn{color:#ffd7a1;border-color:rgba(245,158,11,.35)}
    .chip.bad{color:#ffb2b2;border-color:rgba(239,68,68,.35)}
    footer{color:var(--muted);font-size:11px;padding:10px 14px 0}
  </style>
</head>

<body>
  <header class="wrap">
    <h1>最強777</h1>
    <div class="sub">入力最小 → 母集団を自動算出 → ロト6/ミニロトを同時に即出力（勝負日モード）</div>
  </header>

  <main class="wrap">
    <!-- 入力 -->
    <section class="card">
      <h2>入力 <span class="note">※フィルター/スコアは常時ON（操作不要）</span></h2>

      <div class="split"></div>

      <div class="gridLabel">
        <div><b>ロト6（必須 / 6個）</b></div>
        <div class="smalltag">数字のみでOK（1マス1数字）</div>
      </div>
      <div class="numgrid" id="gridL6"></div>
      <div class="note" style="margin-top:8px">重複・範囲外はエラー（1〜43）</div>

      <div class="split"></div>

      <div class="gridLabel">
        <div><b>ミニロト（任意 / 5個）</b></div>
        <div class="smalltag">入れると連動ボーナスが乗る</div>
      </div>
      <div class="numgrid mini" id="gridMini"></div>
      <div class="note" style="margin-top:8px">重複・範囲外はエラー（1〜31）</div>

      <div class="split"></div>

      <div class="btns">
        <button id="btnCalc">計算する</button>
        <button id="btnReset" class="secondary">クリア</button>
      </div>

      <div class="statusBar">
        <div class="pill" id="pillStep">
          <div class="left">
            <span class="dot idle" id="dotStep"></span>
            <div>
              <div class="t1" id="stepTitle">準備</div>
              <div class="t2" id="stepSub">準備OK → 入力して計算</div>
            </div>
          </div>
          <div class="right" id="stepRight">—</div>
        </div>

        <div class="pill" id="pillJudge">
          <div class="left">
            <span class="dot idle" id="dotJudge"></span>
            <div>
              <div class="t1" id="judgeTitle">未計算</div>
              <div class="t2" id="judgeSub">未計算 / OK / 入力不足 / エラー</div>
            </div>
          </div>
          <div class="right" id="judgeRight">—</div>
        </div>
      </div>
    </section>

    <!-- 結果：ロト6 -->
    <section class="card">
      <h2>結果（ロト6） <span class="note">計算完了 → この7で勝負</span></h2>

      <div class="outTop">
        <div class="bigNum mono" id="outL6Mother">—</div>
        <div class="bigMeta" id="outL6Meta">固定（自動・強め）：—　／　削除は自動判定（入力不要）</div>
      </div>

      <div class="split"></div>

      <div class="note"><b>予想（固定1で現実寄り）</b>：<span id="outL6Count">—</span></div>
      <div id="outL6Tickets"></div>
    </section>

    <!-- 結果：ミニロト -->
    <section class="card">
      <h2>結果（ミニロト） <span class="note">計算完了 → この母集団で勝負</span></h2>

      <div class="outTop">
        <div class="bigNum mono" id="outMiniMother">—</div>
        <div class="bigMeta" id="outMiniMeta">固定（自動）：—　／　削除は自動判定（入力不要）</div>
      </div>

      <div class="split"></div>

      <div class="note"><b>予想（固定1）</b>：<span id="outMiniCount">—</span></div>
      <div id="outMiniTickets"></div>
    </section>

    <footer>
      ※このツールは「見やすさ＆勝負しやすさ」優先。チェック条件は裏で常時ON、結果はスッキリ表示。
    </footer>
  </main>

  <script>
    // ========= Utils =========
    const $ = (id)=>document.getElementById(id);
    const pad2 = (n)=>String(n).padStart(2,"0");
    const uniq = (arr)=>Array.from(new Set(arr));
    const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));

    function setStep(state, rightText=""){
      // state: idle / run / done
      const map = {
        idle:{dot:"idle", title:"準備", sub:"準備OK → 入力して計算", right:rightText||"—"},
        run :{dot:"warn", title:"処理中", sub:"処理中…", right:rightText||"…"},
        done:{dot:"good", title:"完了", sub:"計算完了 → この7で勝負", right:rightText||"完了"},
      };
      const s = map[state]||map.idle;
      $("dotStep").className = "dot " + s.dot;
      $("stepTitle").textContent = s.title;
      $("stepSub").textContent = s.sub;
      $("stepRight").textContent = s.right;
    }
    function setJudge(kind, rightText=""){
      // kind: idle / ok / lack / err
      const map = {
        idle:{dot:"idle", title:"未計算", sub:"未計算 / OK / 入力不足 / エラー", right:rightText||"—"},
        ok  :{dot:"good", title:"OK", sub:"未計算 / OK / 入力不足 / エラー", right:rightText||"OK"},
        lack:{dot:"warn", title:"入力不足", sub:"未計算 / OK / 入力不足 / エラー", right:rightText||"不足"},
        err :{dot:"bad", title:"エラー", sub:"未計算 / OK / 入力不足 / エラー", right:rightText||"NG"},
      };
      const s = map[kind]||map.idle;
      $("dotJudge").className = "dot " + s.dot;
      $("judgeTitle").textContent = s.title;
      $("judgeSub").textContent = s.sub;
      $("judgeRight").textContent = s.right;
    }

    function buildGrid(containerId, count, cap){
      const root = $(containerId);
      root.innerHTML = "";
      for(let i=0;i<count;i++){
        const div = document.createElement("div");
        div.className = "box";
        div.innerHTML = `
          <input inputmode="numeric" pattern="[0-9]*" placeholder="--" data-idx="${i}">
          <div class="cap">${cap}${i+1}</div>
        `;
        root.appendChild(div);
      }
      // 2桁に整形（入力しやすく）
      root.querySelectorAll("input").forEach(inp=>{
        inp.addEventListener("input", ()=>{
          let v = inp.value.replace(/[^\d]/g,"");
          if(v.length>2) v = v.slice(0,2);
          inp.value = v;
        });
      });
    }

    function readGrid(containerId, min, max){
      const inputs = Array.from($(containerId).querySelectorAll("input"));
      const nums = inputs.map(i=>i.value.trim()).filter(Boolean).map(v=>parseInt(v,10));
      // 未入力がある場合は null を混ぜない
      if(nums.length !== inputs.filter(i=>i.value.trim()!=="").length) return {ok:false, err:"数字が不正です"};
      // 必須は呼び出し側で確認
      // 範囲/重複チェック
      for(const n of nums){
        if(!Number.isInteger(n)) return {ok:false, err:"数字が不正です"};
        if(n<min || n>max) return {ok:false, err:`範囲外（${min}〜${max}）`};
      }
      if(uniq(nums).length !== nums.length) return {ok:false, err:"重複があります"};
      return {ok:true, nums};
    }

    // ========= Scoring (軽量・スマート) =========
    // データが少ない前提で「それっぽく強め」に寄せる
    function scoreNumber(n, max, lastSet, crossSet){
      const mid = (max+1)/2;
      const distMid = Math.abs(n - mid);          // 中央寄りを少し優遇
      const midScore = 2.2 - (distMid / mid) * 1.2; // だいたい 1.0〜2.2
      const pullBonus = lastSet.has(n) ? 3.0 : 0; // “引っ張り”は大きく
      const crossBonus = crossSet.has(n) ? 1.2 : 0; // 連動（ミニ↔ロト6）
      // 鏡ペア（ロト6: 44-n / ミニ: 32-n）
      const mirror = (max+1) - n;
      const mirrorBonus = (lastSet.has(mirror) || crossSet.has(mirror)) ? 0.8 : 0;
      // 偏り抑制の軽いノイズ（固定的）
      const noise = ((n*73)%17) / 50; // 0〜0.32
      return midScore + pullBonus + crossBonus + mirrorBonus + noise;
    }

    function pickMotherSet(max, wantCount, lastNums, crossNums){
      const lastSet = new Set(lastNums);
      const crossSet = new Set(crossNums);

      const scored = [];
      for(let n=1;n<=max;n++){
        const sc = scoreNumber(n, max, lastSet, crossSet);
        scored.push({n, sc});
      }
      scored.sort((a,b)=>b.sc - a.sc);

      // 固定（引っ張り）候補：lastNumsの中で最もスコア高い1個
      const pull = lastNums.length
        ? [...lastNums].map(n=>({n, sc: scored.find(x=>x.n===n).sc})).sort((a,b)=>b.sc-a.sc)[0].n
        : null;

      // 母集団に pull を必ず入れて、残りを上位から埋める
      const mother = [];
      if(pull) mother.push(pull);

      for(const x of scored){
  if(mother.length>=wantCount) break;
  if(mother.includes(x.n)) continue;

  // ★重要：前回数字は「引っ張り1個」以外は入れない
  if(lastSet.has(x.n) && x.n !== pull) continue;

  mother.push(x.n);
}

      mother.sort((a,b)=>a-b);

      return {mother, pull, scoredMap: new Map(scored.map(x=>[x.n,x.sc]))};
    }

    // ========= Ticket generation =========
    // ロト6：母集団7 & pull固定 → 6通り（= pull以外の1個を順に落とす）
    function genTicketsL6(mother7, pull){
      const arr = mother7.slice().sort((a,b)=>a-b);
      const others = arr.filter(n=>n!==pull);
      // pullがなければ単純に7C6（7通り）だが今回は “引っ張り1固定” を優先
      if(!pull){
        // fallback: 7C6 = 7枚
        const t = [];
        for(let i=0;i<arr.length;i++){
          const one = arr.filter((_,idx)=>idx!==i);
          t.push(one);
        }
        return t;
      }
      // 6通り
      const tickets = [];
      for(let i=0;i<others.length;i++){
        const drop = others[i];
        const keep = arr.filter(n=>n!==drop);
        // keepは6個
        tickets.push(keep);
      }
      return tickets;
    }

    // ミニ：母集団6 & pull固定 → 5通り（pull以外の1個を落として5個）
    function genTicketsMini(mother6, pull){
      const arr = mother6.slice().sort((a,b)=>a-b);
      const others = arr.filter(n=>n!==pull);
      if(!pull){
        // fallback: 6C5=6枚
        const t = [];
        for(let i=0;i<arr.length;i++){
          const one = arr.filter((_,idx)=>idx!==i);
          t.push(one);
        }
        return t;
      }
      const tickets = [];
      for(let i=0;i<others.length;i++){
        const drop = others[i];
        const keep = arr.filter(n=>n!==drop); // 5個
        tickets.push(keep);
      }
      return tickets;
    }

    function analyzeTicket(nums, max, lastSet, scoreMap){
      const sorted = nums.slice().sort((a,b)=>a-b);
      // 連番
      let consec = 0;
      for(let i=1;i<sorted.length;i++){
        if(sorted[i] === sorted[i-1]+1) consec++;
      }
      // 一致（引っ張り数）
      const hit = sorted.filter(n=>lastSet.has(n)).length;

      // 小中大バランス（ざっくり）
      const third = max/3;
      const small = sorted.filter(n=>n<=third).length;
      const mid   = sorted.filter(n=>n>third && n<=2*third).length;
      const big   = sorted.filter(n=>n>2*third).length;

      // スコア：各数字スコア合計＋軽い構造ボーナス
      let sc = 0;
      for(const n of sorted) sc += (scoreMap.get(n)||0);
      // バランスが極端だと少し減点
      const skew = Math.max(small,mid,big) - Math.min(small,mid,big);
      sc -= skew*0.25;
      // 連番が適度なら加点（0〜2くらい）
      if(consec===1) sc += 0.4;
      if(consec===2) sc += 0.6;
      if(consec>=3) sc -= 0.3;

      // ランク
      let label = "標準";
      let stars = 1;
      if(sc >= 10.4){ label="強い"; stars=3; }
      else if(sc >= 10.1){ label="強気"; stars=2; }
      else if(sc >= 9.8){ label="堅い"; stars=1; }
      else if(sc >= 9.4){ label="様子見"; stars=1; }
      else { label="弱め"; stars=1; }

      return {sorted, consec, hit, small, mid, big, sc: Math.round(sc*10)/10, label, stars};
    }

    function renderTickets(targetId, tickets, max, lastNums, scoreMap){
      const lastSet = new Set(lastNums);
      const analyzed = tickets.map(t=>analyzeTicket(t, max, lastSet, scoreMap));
      // 高スコア順に並べる
      analyzed.sort((a,b)=>b.sc - a.sc);

      const root = $(targetId);
      root.innerHTML = "";
      for(const a of analyzed){
        const div = document.createElement("div");
        div.className = "ticket";
        const starStr = "★".repeat(a.stars).padEnd(3,"☆");
        const tagClass = a.label==="強い" ? "good" : (a.label==="弱め" ? "bad" : "warn");
        div.innerHTML = `
          <div class="stars">${starStr}</div>
          <div class="tMain">
            <div class="tNums mono">${a.sorted.map(pad2).join(" ")}</div>
            <div class="chips">
              <span class="chip ${tagClass}">${a.label}</span>
              <span class="chip">一致:${a.hit}</span>
              <span class="chip">連番:${a.consec}</span>
              <span class="chip">小中大:${a.small}-${a.mid}-${a.big}</span>
              <span class="chip">Score:${a.sc}</span>
            </div>
          </div>
        `;
        root.appendChild(div);
      }
      return analyzed;
    }

    // ========= UI init =========
    buildGrid("gridL6", 6, "L");
    buildGrid("gridMini", 5, "M");
    setStep("idle");
    setJudge("idle");

    function resetAll(){
      ["gridL6","gridMini"].forEach(id=>{
        $(id).querySelectorAll("input").forEach(i=>i.value="");
      });
      setStep("idle");
      setJudge("idle");
      $("outL6Mother").textContent = "—";
      $("outL6Meta").textContent = "固定（自動・強め）：—　／　削除は自動判定（入力不要）";
      $("outL6Count").textContent = "—";
      $("outL6Tickets").innerHTML = "";

      $("outMiniMother").textContent = "—";
      $("outMiniMeta").textContent = "固定（自動）：—　／　削除は自動判定（入力不要）";
      $("outMiniCount").textContent = "—";
      $("outMiniTickets").innerHTML = "";
    }

    $("btnReset").addEventListener("click", resetAll);

    $("btnCalc").addEventListener("click", ()=>{
      setStep("run");
      setJudge("idle");

      // ロト6必須
      const l6 = readGrid("gridL6", 1, 43);
      if(!l6.ok){
        setStep("idle");
        setJudge("err", l6.err);
        return;
      }
      if(l6.nums.length !== 6){
        setStep("idle");
        setJudge("lack", "ロト6は6個必須");
        return;
      }

      // ミニ任意（0 or 5）
      const mi = readGrid("gridMini", 1, 31);
      if(!mi.ok){
        setStep("idle");
        setJudge("err", mi.err);
        return;
      }
      if(!(mi.nums.length === 0 || mi.nums.length === 5)){
        setStep("idle");
        setJudge("lack", "ミニは0か5個");
        return;
      }

      setJudge("ok");

      // 連動：互いの入力を cross として渡す
      const l6Cross = mi.nums || [];
      const miCross = l6.nums || [];

      // ロト6：母集団7（引っ張り1固定）
      const l6Pick = pickMotherSet(43, 7, l6.nums, l6Cross);
      const l6Mother = l6Pick.mother;
      const l6Pull = l6Pick.pull;

      // ミニ：母集団6（引っ張り1固定）
      const miPick = (mi.nums.length===5)
        ? pickMotherSet(31, 6, mi.nums, miCross)
        : {mother: [], pull: null, scoredMap: new Map()};

      // 出力（ロト6）
      $("outL6Mother").textContent = l6Mother.map(pad2).join(" ");
      $("outL6Meta").textContent =
        `固定（自動・強め）：${l6Pull ? pad2(l6Pull) : "—"}　／　削除は自動判定（入力不要）`;

      const l6Tickets = genTicketsL6(l6Mother, l6Pull);
      $("outL6Count").textContent = `${l6Tickets.length}通り（固定1）`;
      renderTickets("outL6Tickets", l6Tickets, 43, l6.nums, l6Pick.scoredMap);

      // 出力（ミニ）
      if(mi.nums.length===5){
        $("outMiniMother").textContent = miPick.mother.map(pad2).join(" ");
        $("outMiniMeta").textContent =
          `固定（自動）：${miPick.pull ? pad2(miPick.pull) : "—"}　／　削除は自動判定（入力不要）`;

        const miTickets = genTicketsMini(miPick.mother, miPick.pull);
        $("outMiniCount").textContent = `${miTickets.length}通り（固定1）`;
        renderTickets("outMiniTickets", miTickets, 31, mi.nums, miPick.scoredMap);
      }else{
        $("outMiniMother").textContent = "—（ミニ未入力）";
        $("outMiniMeta").textContent = "ミニは任意。入力すると連動ボーナス＆ミニ予想も出ます。";
        $("outMiniCount").textContent = "—";
        $("outMiniTickets").innerHTML = "";
      }

      setStep("done", "完了");
    });

    // Service Worker
    if("serviceWorker" in navigator){
      navigator.serviceWorker.register("./sw.js").catch(()=>{});
    }
  </script>
</body>
</html>
